"use strict";

module.exports = function (grunt) {
    var path = require("path");
    var fs = require("fs");
    var crc32 = require("crc-32");
    var MersenneTwister = require('mersenne-twister');
    var mersenneGenerator = new MersenneTwister();
    var ERROR_TYPE = "ERROR";
    var WARN_TYPE = "WARN";
    var ABORT_TYPE = "ABORT";
    var JSON_PATH = "../mobile/json";
    var MENU_PATH = [];
    var PROJECT_NAME = "zeedhi_project";
    var CONTAINERS_JSON_FILE_NAME = "containers.json";
    var hasParametersFromCommandLine = false;
    var logMessages = "";
    var incrementalId;
    var fileIsDirty;
    var jsonIdsIndexedByFilePath;
    var duplicatedIdErrors;
    var missingIdErrors;
    var validationOnly;

    var collections = {
        "groupMenu": "id",
        "menus": "id",
        "notifications": "id",
        "widgets": "id",
        "fields": "id",
        "actions": "id",
        "events": "id",
        "fieldGroups": "id",
        "columns": "id"
    };

    function isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }

    function hasItemInCollection(item, collection) {
        for (var i in collection) {
            if (collection[i] === item) {
                return true;
            }
        }
        return false;
    }

    function printGruntLog(message, type) {
        if (!hasParametersFromCommandLine) {
            var identificationMessage = type && type != ABORT_TYPE ? "\x1b[31m" + type + "\x1b[0m " : "";
            if(type == ABORT_TYPE){
                grunt.warn(identificationMessage + message);
            } else if (type == ERROR_TYPE) {
                grunt.log.error(identificationMessage + message);
            } else {
                grunt.log.writeln(identificationMessage + message);
            }
        } else {
            logMessages += type ? (type + ": ") : "";
            logMessages += message + "\n";
        }
    }

    function addDuplicatedIdError(id, filePath, otherFilePath) {
        var errorItem = {
            id: id,
            filePath: filePath,
            otherFilePath: otherFilePath
        };

        duplicatedIdErrors.push(errorItem);
    }

    function readJSON(filePath) {
        return grunt.file.readJSON(filePath, { encoding: "utf8" });
    }

    function getHashCode(str) {
        return '' + Math.abs(crc32.str(str)) + mersenneGenerator.random_int() + incrementalId++;
    }

    function hasAnyChildInCollections(obj) {
        for (var key in collections) {
            if (collections.hasOwnProperty(key) && obj.hasOwnProperty(key)) {
                return true;
            }
        }
    }

    function getPropertyValueInCollections(property) {
        for (var key in collections) {
            if (collections.hasOwnProperty(key) && key === property) {
                return collections[key];
            }
        }
    }

    function getObjectChildrenInCollections(obj) {
        return Object.keys(collections).filter(function (key) {
            return obj.hasOwnProperty(key);
        });
    }

    function createTypeWarn(type, property, fileName) {
        printGruntLog("Expecting " + type + ", but got " + typeof property + " at '" +
            property + "' property at file" + "'" + fileName + "'", WARN_TYPE);
    }

    function createDuplicatedIdError(duplicatedId, filePath, otherFilePath) {
        var message = "The same id (" + duplicatedId + ") was found ";
        if (otherFilePath) {
            message += "at both files:\n" + filePath + "\n" + otherFilePath;
        } else {
            message += "twice at the same file: \n" + filePath;
        }
        message += "\n";
        printGruntLog(message, ERROR_TYPE);
    }

    function logErrors() {
        duplicatedIdErrors.forEach(function (error) {
            createDuplicatedIdError(error.id, error.filePath, error.otherFilePath);
        });

        missingIdErrors.forEach(function(fileName){
            var message = "Missing id on file " + fileName + ".";
            printGruntLog(message, ERROR_TYPE);
        });

        printGruntLog("Aborting the script.", ABORT_TYPE);
    }

    function searchForDuplicatedIds(id, filePath) {
        Object.keys(jsonIdsIndexedByFilePath).forEach(function (indexPath) {
            if (indexPath !== filePath) {
                if (hasItemInCollection(id, jsonIdsIndexedByFilePath[indexPath])) {
                    addDuplicatedIdError(id, indexPath, filePath);
                }
            }
        });
    }

    function addIdToIndex(id, filePath) {
        if (!jsonIdsIndexedByFilePath[filePath]) {
            jsonIdsIndexedByFilePath[filePath] = [id];
            searchForDuplicatedIds(id, filePath);
        } else {
            if (hasItemInCollection(id, jsonIdsIndexedByFilePath[filePath])) {
                addDuplicatedIdError(id, filePath);
            }
            jsonIdsIndexedByFilePath[filePath].push(id);
            searchForDuplicatedIds(id, filePath);
        }
    }

    function addMissingIdError(filePath){
        missingIdErrors.push(filePath);
    }

    function generateContainerId(container, subDir, fileName, replaceIds, parent) {
        if (fileName.indexOf(CONTAINERS_JSON_FILE_NAME) === -1 && !parent) { // Add the json first id (Containers)
            if (hasAnyChildInCollections(container) && (!container.id || replaceIds)) {
                if(validationOnly && !container.id){
                    addMissingIdError(fileName);
                } else {
                    container.id = getHashCode(fileName + container.name + container.label);
                    fileIsDirty = true;
                }
            } else if (container.id && !replaceIds) {
                addIdToIndex(container.id, path.join(subDir, fileName));
            }
        }
    }

    function generateIdForItemInCollection(item, idx, subDir, fileName, idProperty, replaceIds) {
        if (!item[idx][idProperty] || replaceIds) {
            if(validationOnly && !item[idx][idProperty]){
                addMissingIdError(fileName);
            } else {
                delete item[idx][idProperty];
                var idHash = getHashCode(fileName + item.name + item.label);
                var newObj = getObjectWithUpdatedId(item[idx], idProperty, idHash);
                item[idx] = newObj;
                fileIsDirty = true;
            }
        } else {
            addIdToIndex(item[idx][idProperty], path.join(subDir, fileName));
        }
    }

    function getObjectWithUpdatedId(obj, idProperty, idHash) {
        var newObj = {};
        newObj[idProperty] = idHash;
        Object.keys(obj).forEach(function (objKey) {
            newObj[objKey] = obj[objKey];
        });

        return newObj;
    }

    function iterateObjectChildrenInCollection(objToCheck, subDir, fileName, projectName, replaceIds) {
        var childrenToIterate = getObjectChildrenInCollections(objToCheck);

        childrenToIterate.forEach(function (child) {
            if (Array.isArray(objToCheck[child])) {
                jsonDeepSearch(objToCheck[child], subDir, fileName, projectName, replaceIds, child);
            } else {
                createTypeWarn("array", child, path.join(subDir, fileName));
            }
        });

        if (objToCheck[projectName]) {
            jsonDeepSearch(objToCheck[projectName], subDir, fileName, projectName, replaceIds);
        }
    }

    function jsonDeepSearch(item, subDir, fileName, projectName, replaceIds, parent) {
        if (isObject(item)) {
            generateContainerId(item, subDir, fileName, replaceIds, parent);
            iterateObjectChildrenInCollection(item, subDir, fileName, projectName, replaceIds);
        } else if (Array.isArray(item) && parent) {
            var idProperty = getPropertyValueInCollections(parent);
            for (var idx in item) {
                if (isObject(item[idx])) {
                    generateIdForItemInCollection(item, idx, subDir, fileName, idProperty, replaceIds);
                    iterateObjectChildrenInCollection(item[idx], subDir, fileName, projectName, replaceIds);
                } else {
                    createTypeWarn("object", parent + "[" + idx + "]", path.join(subDir, fileName));
                }
            }
        }
    }

    function readContainersJson(absPath, subDir, fileName, projectName, replaceIds) {
        var fileJson = readJSON(absPath);
        fileIsDirty = false;
        jsonDeepSearch(fileJson, subDir, fileName, projectName, replaceIds);
        // Only replaces the file if it has changed
        if (fileIsDirty) {
            replaceFile(fileJson, absPath);
        }
    }

    function readMenuFile(absPath, fileName, replaceIds) {
        var fileJson = readJSON(absPath);
        fileIsDirty = false;
        jsonDeepSearch(fileJson, "", fileName, "", replaceIds, "groupMenu");
        if (fileIsDirty) {
            replaceFile(fileJson, absPath);
        }
    }

    function iterateFolders(folders, replaceIds) {
        folders.forEach(function (folder) {
            var containersFile = path.join(folder.path, CONTAINERS_JSON_FILE_NAME);
            if (grunt.file.exists(containersFile)) {
                readContainersJson(fs.realpathSync(containersFile), folder.path, CONTAINERS_JSON_FILE_NAME, folder.projectName, replaceIds);
            }

            var componentsFolder = folder.inComponentsPath ? folder.path : path.join(folder.path, 'containers');
            if (grunt.file.isDir(componentsFolder)) {
                grunt.file.recurse(componentsFolder, function (absPath, rootDir, subDir, fileName) {
                    if (isJsonFile(fileName)) {
                        readContainersJson(absPath, subDir || rootDir, fileName, folder.projectName, replaceIds);
                    }
                });
            }
        });
    }

    function isJsonFile(fileName) {
        return fileName && ~fileName.indexOf(".json");
    }

    function iterateMenuFiles(menuPath, replaceIds) {
        menuPath.forEach(function (menu) {
            readMenuFile(fs.realpathSync(menu), menu.split('/').shift(), replaceIds);
        });
    }

    function replaceFile(fileObj, path) {
        var content = JSON.stringify(fileObj, null, 4);
        grunt.file.write(path, content, { encoding: 'utf8' });
        printGruntLog("Modified " + path);
    }

    function mapJsonPath(jsonPath, inComponentsPath) {
        var mappedFolders = [];
        jsonPath.forEach(function (pathItem, index) {
            if (isObject(pathItem)) {
                if (pathItem.hasOwnProperty("path")) {
                    mappedFolders.push({
                        path: pathItem.path,
                        projectName: pathItem.projectName || PROJECT_NAME,
                        inComponentsPath: inComponentsPath
                    });
                } else {
                    printGruntLog("jsonPath at position " + index + " doesn't have a path property.");
                }
            } else if (typeof pathItem === "string") {
                mappedFolders.push({
                    path: pathItem,
                    projectName: PROJECT_NAME,
                    inComponentsPath: inComponentsPath
                });
            } else {
                printGruntLog("jsonPath at position " + index + " should be a string or object, but is a " +
                    typeof pathItem + ".");
            }
        });

        return mappedFolders;
    }

    function saveLogFile(path) {
        if (path && logMessages) {
            grunt.file.write(path, logMessages, { encoding: 'utf8' });
        }
    }

    grunt.registerTask("zhIdGenerator", "Generate ids for json items like widgets and actions", function (arg1, arg2) {
        // Merge task-specific and/or target-specific options with these defaults.
        var options = this.options({
            jsonPath: JSON_PATH,
            replaceIds: false,
            menuPath: MENU_PATH
        });
        var onlyInFileMode = arg1 == "onlyInFile";
        hasParametersFromCommandLine = typeof arg1 != "undefined";
        validationOnly = !!grunt.option('validationOnly');

        if (!Array.isArray(options.jsonPath) || !Array.isArray(options.menuPath)) {
            printGruntLog("Invalid arguments. The 'jsonPath' and 'menuPath' parameters should be array. Please check your arguments.");
        } else {
            jsonIdsIndexedByFilePath = {};
            duplicatedIdErrors = [];
            missingIdErrors = [];
            incrementalId = new Date().getMilliseconds();
            var componentsFolder = mapJsonPath(options.jsonComponentsPath || [], true);
            var mappedFolders = mapJsonPath(options.jsonPath).concat(componentsFolder);

            if (!onlyInFileMode) {
                var replaceIds = !hasParametersFromCommandLine ? options.replaceIds : arg1 == "true";
                iterateFolders(mappedFolders, replaceIds);
                iterateMenuFiles(options.menuPath, replaceIds);
                if (duplicatedIdErrors.length > 0 || missingIdErrors.length > 0) {
                    logErrors();
                } else {
                    printGruntLog("Done without errors.");
                }
            } else {
                var fileName = arg2;
                var additionalPath = fileName == CONTAINERS_JSON_FILE_NAME ? "" : "/containers/";
                var realPath;
                mappedFolders.some(function (folder) {
                    realPath = folder.path + additionalPath;
                    if (grunt.file.exists(realPath + fileName)) {
                        readContainersJson(fs.realpathSync(realPath + fileName), realPath, fileName, PROJECT_NAME, false);
                        return true;
                    }
                    return false;
                });
            }
        }
        if (hasParametersFromCommandLine && !onlyInFileMode) {
            saveLogFile(arg2);
        }
    });
};
